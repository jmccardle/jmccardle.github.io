# Refactored TCOD Tutorial - Table of Contents

## Part 1 - Drawing the @ symbol and moving it around
This refactored version establishes a complete game package architecture with entity-centric design, action-based command patterns, and sophisticated input handling from day one. Rather than teaching quick-and-dirty approaches that require painful refactoring later, it introduces professional patterns like Command, Observer, and Strategy naturally. The foundation includes complete movement key support (arrows, numpad, vi keys) and an Engine class that anticipates complex game systems. Students learn industry-standard practices including type hints, proper separation of concerns, and extensible architecture that scales gracefully from simple movement to complex RPG mechanics.

## Part 2 - The generic Entity, render functions, and the map
Part 2 introduces a sophisticated entity management system with flexible parent-child relationships through the `place()` method, enabling seamless entity movement between maps and inventories in future parts. The GameMap becomes self-aware, managing its own entities and rendering, while the tile system prepares for field of view with light/dark variants. The architecture demonstrates professional patterns like TYPE_CHECKING for import cycles and property-based access, creating clean boundaries between systems. This forward-thinking design prevents the technical debt that typically accumulates in tutorial projects as they grow in complexity.

## Part 3 - Generating a dungeon
The refactored dungeon generation moves all procedural logic into a dedicated `procgen.py` module, preventing the GameMap from becoming monolithic and establishing patterns for future generation algorithms. It introduces entity-centric generation using the established `place()` method, switches to a "carving" approach starting with solid walls, and implements sophisticated tunnel generation using iterators and TCOD's Bresenham algorithm. The modular architecture with proper separation of concerns makes it trivial to add new room types, generation algorithms, or dungeon themes. Students learn real-world programming patterns including iterator protocols, property decorators, and how early architectural decisions enable or constrain future development.

## Part 4 - Field of View
Part 4's refactoring goes beyond basic FOV implementation to establish architectural patterns that support future visual complexity like multiple light sources, temporary vision modifications, and environmental effects. The centralized `update_fov()` method in the Engine class and intelligent use of NumPy's `np.select()` for conditional rendering create a system that scales elegantly. Strategic FOV update points (initialization, post-action, after enemy turns) anticipate features where visibility changes dynamically. The comprehensive type annotations and early separation of concerns between Engine, GameMap, and Tiles demonstrate how thoughtful architecture in simple features pays dividends as complexity grows.

## Part 5 - Placing Enemies
This refactored version introduces sophisticated entity management with automatic spawn registration, property-based action design with `dest_xy` and `target_actor`, and proper turn management in the event handling system rather than the engine. The `BumpAction` pattern elegantly handles both movement and combat without requiring input system rewrites later. By establishing these patterns early when learners have mental bandwidth, the tutorial avoids the multiple painful refactoring points of the original. The architecture anticipates AI behaviors, complex targeting, and entity queries, creating a foundation that scales naturally as combat and interaction systems are added.

## Part 6 - Doing (and taking) some damage
Part 6 introduces a complete component system architecture with BaseComponent and organized modules, establishing the foundation for professional-grade game development. The Actor-based entity hierarchy cleanly separates entities that can act from static objects, while sophisticated AI with TCOD pathfinding creates intelligent enemy behavior. The entity factory pattern centralizes configuration for easy balancing and modding, and the render order system prevents visual chaos. By implementing these patterns early, the refactored version avoids the "great refactoring wall" that typically hits tutorials around parts 8-10, teaching students component thinking and professional patterns from the start.

## Part 7 - Creating the Interface
The refactored UI system demonstrates forward-thinking design with explicit module imports that prevent circular dependencies, a color system designed as extensible configuration constants, and enhanced message logging with proper text wrapping and class method rendering. Modern event handling includes proper mouse coordinate conversion and Vi-style navigation support from the start. The separation of data modeling, rendering logic, and user interaction creates a maintainable UI architecture. Students learn functional programming concepts through pure render functions and professional error handling patterns that make UI development both robust and extensible.

## Part 8 - Items and Inventory
This version implements a revolutionary parent-child entity system where entities can exist in maps, inventories, or any container through a flexible `parent` relationship instead of rigid `gamemap` references. The component system modernization creates consistent naming throughout the codebase while decoupling AI from passive components. Exception-driven actions with `Impossible` enable rich error messaging, while the sophisticated `ActionOrHandler` pattern creates complex UI flows. This architectural overhaul unlocks possibilities for equipment slots, shops, containers, and complex item interactions without requiring future refactoring.

## Part 9 - Ranged Scrolls and Targeting
Part 9 establishes a comprehensive targeting system architecture using callback patterns that decouple targeting UI from specific actions, making new ranged abilities trivial to add. Advanced visual feedback shows area-of-effect previews before actions, while the flexible ItemAction design handles both targeted and non-targeted items seamlessly. The modular AI state management with previous state storage enables complex status effect stacking. By implementing three distinct targeting paradigms (auto, single, area), the refactored version creates reusable patterns for any future ranged interaction, turning three simple scrolls into a complete framework for ranged gameplay.

## Part 10 - Saving and loading
Part 10 revolutionizes the event handling system with BaseEventHandler and ActionOrHandler patterns that eliminate direct engine manipulation and create composable UI flows. The modular game setup moves initialization into dedicated functions, while sophisticated exception handling distinguishes between different quit scenarios. The PopupMessage handler demonstrates elegant error display through composition rather than inheritance. These architectural improvements transform save/load from a simple serialization lesson into a masterclass in event-driven architecture, creating patterns that make every subsequent UI addition cleaner and more maintainable.

## Part 11 - Delving into the Dungeon
The introduction of the GameWorld class encapsulates all dungeon state and generation parameters, creating a clean abstraction that enables save/load complexity and world-specific rules. Systematic import refactoring using module-level imports prepares for plugin architectures and better testing strategies. The Level component demonstrates mature component design with self-contained XP and stat management that fits seamlessly into the existing pattern. Enhanced UI patterns including defensive design prevent accidental exits from critical decisions, while smart stair rendering avoids tile system complexity. Every change serves multiple purposes: immediate functionality, future extensibility, and architectural evolution.

## Part 12 - Increasing Difficulty
Part 12 transforms difficulty scaling from hard-coded values into a sophisticated data-driven system using tuple-based configuration lists and weighted entity selection with `random.choices`. The generic `get_entities_at_random` function eliminates code duplication while supporting any entity type through the same interface. Modular imports prepare for complex entity factory systems, while flexible floor-based progression enables sophisticated difficulty curves with plateaus and spikes. This refactoring demonstrates how elegant data structures create more interesting gameplay than complex algorithms, teaching students to think about scalability and configuration-driven design from the beginning.

## Part 13 - Gearing Up - Equipment System
The final part implements a robust equipment system with modular import architecture using explicit paths, rigorous type safety with runtime assertions, and a character screen showing real-time stat calculations including equipment bonuses. The flexible bonus system supports complex multi-stat interactions while maintaining tutorial simplicity, and the extensible slot system using dynamic attribute access makes adding new equipment types trivial. Separation of base and bonus values enables percentage bonuses and temporary effects, while fail-fast error handling prevents entire categories of equipment bugs. This transforms a simple equipment system into a blueprint for building maintainable, extensible game systems that scale with project growth.
